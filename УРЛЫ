def heapify(m, i, length=0):
    left = i * 2 + 1
    right = i * 2 + 2
    if left >= len(m) + length:
        return
    elif right >= len(m) + length:
        right = left
    largest = left if m[left] > m[right] else right
    if m[largest] > m[i]:
        m[largest], m[i] = m[i], m[largest]
        heapify(m, largest, length)
def heap_sort(unsorted):
    m = unsorted[:]
    for i in list(range(len(m)//2))[::-1]:
        heapify(m, i)
    for i in range(1, len(m)):
        m[0], m[-i] = m[-i], m[0]
        heapify(m, 0, -i)
    return m


def merge_sort(m):
    if len(m) == 1:
        return m
    else:
        a = merge_sort(m[:len(m)//2])
        b = merge_sort(m[len(m)//2:])
        m = []
        while a and b:
            if a[0] > b[0]:
                m += [b.pop(0)]
            else:
                m += [a.pop(0)]
        return m + a + b

def insertion_sort(unsorted):
    m = unsorted[:]
    for i in range(1,len(m)):
        j = i - 1 
        value = m[i]
        while j >= 0 and m[j] > value:
            m[j+1] = m[j]
            j -= 1
        m[j+1] = value
    return m

def selection_sort(unsorted):
    temp = unsorted[:]
    m = []
    for i in range(len(temp)): # n
        min = 0 # n-1
        for j in range(1, len(temp)): # n-1
            if temp[min] > temp[j]: 
                min = j
        m += [temp[min]] # n-1
        temp.pop(min) # n-1
    return m
    
import random

from sorting import insertion_sort, selection_sort, merge_sort


sortingMethods = [insertion_sort, selection_sort, merge_sort]
for method in sortingMethods:
    for i in range(100):
        a = random.sample(range(1000),250)
        try:
            assert sorted(a) == method(a)
        except AssertionError:
            print("Failed by " + method.__name__ + " in:" + str(a))
            print("Sort result:" + str(method(a)))
            raise AssertionError
    print("Test successfully passed by " + method.__name__)

